/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.midas.classify.models;

import com.midas.classify.util.DataEntry;
import com.midas.classify.util.DataSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.TreeMap;

/*
 * Clasificacion de vectores por medio del algoritmo de aprendizaje
 * supervisado ID3.
 * 
 * @author eduarc (Eduar Castrillo)
 */
public class ID3 extends SupervisedClassifier {
  
  private Node root;
  private int[] attrFreq;
  private boolean[] fixedAttribute;
  
  public ID3(DataSet trSet) {
    super(trSet);
    
    int n = trainingData.size();
    int t = trainingData.getNumAttributes();
    
    Node dummy = new Node("dummyNode", 0);
    ArrayList<Integer> initialSet = new ArrayList(n);
    for (int i = 0; i < n; ++i) {
      initialSet.add(i);
    }
    fixedAttribute = new boolean[t];
    Arrays.fill(fixedAttribute, false);
    fixedAttribute[classAttribute] = true;
    attrFreq = new int[n];
    Arrays.fill(attrFreq, 0);
    
    dummy.addEdge("dummyVal", makeTree(initialSet));
      // obtener nodo raiz
    root = dummy.getNode("dummyVal");
  }
  
  /*
   * Predice la clase del vector de entrada.
   */
  @Override
  public String classify(DataEntry entry) {
    Node node = root;
    while (!node.isLeaf()) {
      int attr = entry.getAttribute(node.getName());
      node = node.getNode((String)entry.get(attr));
    }
    return node.getName();
  }
  
  @Override
  public String[] classify(DataSet inputData) {
    
    int sz = inputData.size();
    String[] classy = new String[sz];
    
    for (int i = 0; i < sz; ++i) {
      DataEntry entry = inputData.getEntry(i);
      classy[i] = classify(entry);
    }
    return classy;
  }
  
  private double getEntropy(ArrayList<Integer> set, int attribute) {
    
    double e = 0;
    double sz = set.size();
    TreeMap<Object,Integer> valFreq = getAttributeFrequency(set, attribute);
    
    double logBase = valFreq.size();
    if (logBase != 1) {
      logBase = Math.log(logBase);
    }
    
    for (Object val : valFreq.keySet()) {
      Integer f = valFreq.get(val);
      double p = f/sz;
      double logp = Math.log(p)/logBase;
      e += -p*logp;
    }
    return e;
  }
  
  private ArrayList<Integer> getSubSet(ArrayList<Integer> set, int attribute, String val) {
    
    ArrayList<Integer> subSet = new ArrayList();
    
    for (int i : set) {
      Object[] entry = trainingData.get(i);
      if (entry[attribute].equals(val)) {
        subSet.add(i);
      }
    }
    return subSet;
  }
  
  /*
   * Cuenta la frecuencia de cada valor en countedAttribute en el conjunto set.
   */
  private TreeMap<Object, Integer> getAttributeFrequency(ArrayList<Integer> set, int countedAttribute) {
    
    TreeMap<Object, Integer> freq = new TreeMap();
    int sz = set.size();
    
    for (int i : set) {
      Object[] entry = trainingData.get(i);
      Object val = entry[countedAttribute];
      Integer f = freq.get(val);

      if (f == null) f = 0;
      freq.put(val, 1+f);
    }
    return freq;
  }
  
  /*
   * Divide en subconjuntos a set. Cada valor de attribute configura un subconjunto
   */
  private TreeMap<Object, ArrayList<Integer>> split(ArrayList<Integer> set, int attribute) {
    
    TreeMap<Object, ArrayList<Integer>> subSets = new TreeMap();
    
    for (int i : set) {
      Object[] entry = trainingData.get(i);
      Object val = entry[attribute];
        // Sval
      ArrayList s = subSets.get(val);
      if (s == null) {
        s = new ArrayList();
        subSets.put(val, s);
      }
      s.add(i);
    }
    return subSets;
  }
  
  /*
   * Retorna la ganancia de informacion para set, con respecto a attribute
   */
  private double getGain(ArrayList<Integer> set, int attribute) {
    
    double gain = 0;
    double entropy = getEntropy(set, classAttribute);
    
    double sz = set.size();
    TreeMap<Object, ArrayList<Integer>> subSets = split(set, attribute);
    
    // k, mapea cada Sk
    for (Object k : subSets.keySet()) {
      ArrayList<Integer> Sk = subSets.get(k);
      int isz = Sk.size();
      
      double pSk = isz/sz;
      double eSk = getEntropy(Sk, classAttribute);
      gain += pSk*eSk;
    }
    return entropy-gain;
  }
  
  /*
   * Crea el arbol de decision ID3
   */
  private Node makeTree(ArrayList<Integer> set) {
    
    double entropy = getEntropy(set, classAttribute);
    
    if (entropy == 0) {
      String targetClass = (String)trainingData.get(set.get(0))[classAttribute];
      Node leaf = new Node(targetClass, -1);
      return leaf;
    }
    
    double maxGain = -1;
    int n = trainingData.getNumAttributes();
    int bestAttr = -1;
    
    for (int i = 0; i < n;++i) {
      if (!fixedAttribute[i]) {
        double g = getGain(set, i);
        if (maxGain < g) {
          maxGain = g;
          bestAttr = i;
        }
      }
    }
    
    if (bestAttr == -1) {
      TreeMap<Object, Integer> freqs = getAttributeFrequency(set, classAttribute);
      int maxi = -1;
      String targetClass = "";
      for (Object k: freqs.keySet()) {
        int f = freqs.get(k);
        if (maxi < f) {
          maxi = f;
          targetClass = (String)k;
        }
      }
      return new Node(targetClass, 0);
    }
    
    fixedAttribute[bestAttr] = true;
    Node best = new Node(trainingData.getAttributeName(bestAttr), attrFreq[bestAttr]);
    ++attrFreq[bestAttr];
    ArrayList<String> pos = getTrainingData().getNominalValues(bestAttr);
    
    for (String s : pos) {
      ArrayList<Integer> sub = getSubSet(set, bestAttr, s);
      if (!sub.isEmpty()) {
        best.addEdge(s, makeTree(sub));
      } else {
        TreeMap<Object, Integer> freqs = getAttributeFrequency(set, classAttribute);
        int maxi = -1;
        String targetClass = "";
        for (Object k: freqs.keySet()) {
          int f = freqs.get(k);
          if (maxi < f) {
            maxi = f;
            targetClass = (String)k;
          }
        }
        best.addEdge(s, new Node(targetClass, 0));
      }
    }
    fixedAttribute[bestAttr] = false;
    return best;
  }

  @Override
  public String modelSummary() {
    int n = trainingData.getNumAttributes();
    
    String out = "\n";
    
    out += "Classify - ID3 Model\n";
    out += "------------------------\n\n";
    
    out += "Training Data: "+trainingData.getName()+"\n";
    out += "# Instances:   "+trainingData.size()+"\n";
    out += "# Attributes:  "+n+"\n";
    out += "Attributes:\n";
    for (int i = 0; i < n; ++i) {
      out += "   - "+trainingData.getAttributeName(i)+"\n";
    }
    out += "\n";
    out += "Decision Tree\n";
    out += "root: "+root.getName()+"\n\n";
    
    Queue<Node> Q = new LinkedList();
    Q.add(root);
    
    while (!Q.isEmpty()) {
      Node u = Q.poll();
      out += "\t"+u.getName()+u.getId()+"\n";
      for (String e : u.edges.keySet()) {
        Node v = u.getNode(e);
        if (!v.isLeaf()) {
          out += "\t    "+e+" -> "+v.getName()+v.getId()+"\n";
          Q.add(v);
        } else {
          out += "\t    "+e+" -> "+v.getName()+"\n";
        }
      }
    }
    return out;
  }
  
  /* Nodo en el arbol de decision */
  private class Node {
    
    int id;
    String name;
    TreeMap<String,Node> edges;
    
    public Node(String nam,int id) {
      
      this.id = id;
      name = nam;
      edges = new TreeMap();
    }
    
    public void addEdge(String w,Node v) {
      edges.put(w,v);
    }
    
    public boolean isLeaf() {
      return edges.isEmpty();
    }
    
    public int getId() {
      return id;
    }
    
    public String getName() {
      return name;
    }
    
    public Node getNode(String edge) {
      return edges.get(edge);
    }
  }
  
  /*
   * Imprime el arbol e informacion varia
   */
  @Override
  public String toString() {
    return modelSummary();
  }
}
