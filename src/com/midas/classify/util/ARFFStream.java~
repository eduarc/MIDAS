/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.midas.classify.util;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;

/**
 *
 * @author eduarc
 */
public class ARFFStream extends DataStream {
  
  public static final String COMMENT_SEQ = "%";
  public static final String RELATION_TAG = "@RELATION";
  public static final String ATTRIBUTE_TAG = "@ATTRIBUTE";
  public static final String DATA_TAG = "@DATA";
  
  public static final String NUMERIC_DTYPE = "NUMERIC";
  public static final String REAL_DTYPE = "REAL";
  public static final String INTEGER_DTYPE = "INTEGER";
  public static final String STRING_DTYPE = "STRING";
  public static final String NOMINAL_DTYPE = "}";

  private String relationName;
  private ArrayList<String> attributeName;
  private ArrayList<Integer> attributeType;
  private ArrayList<ArrayList<String>> nominalValues;
  private ARFFDataSet dataSet;
  private int currentLine;
  
  @Override
  public DataSet read(InputStream stream) throws IOException {
    
    currentLine = 0;
    relationName = "";
    attributeName = new ArrayList();
    attributeType = new ArrayList();
    nominalValues = new ArrayList();
    
    BufferedReader reader = new BufferedReader(new InputStreamReader(stream));

    relationName = readRelationName(reader);
    String nextTag = readAttributes(reader);
    
    int n = attributeName.size();
    
    dataSet = new ARFFDataSet(relationName,n);
    
    for (int i = 0; i < n; ++i) {
      int t = attributeType.get(i);
      dataSet.setAttributeType(i,t);
      dataSet.setDimensionName(i,attributeName.get(i));
      if (t == ARFFDataSet.NOMINAL) {
        dataSet.setNominalValues(i,nominalValues.get(i));
      }
    }
    readData(reader,nextTag);
    return dataSet;
  }

  private String readRelationName(BufferedReader reader) throws IOException {
    
    String line;
    while ((line = reader.readLine()) != null) {
      ++currentLine;
      
      line = line.trim();
      if (line.length() == 0 || line.startsWith(COMMENT_SEQ)) {
        continue;
      }
      line = normalice(line);
      
      String upper = line.toUpperCase();
      if (upper.startsWith(RELATION_TAG)) {
        line = line.substring(RELATION_TAG.length());
        return parse(line,1).get(0);
      } else {
        throw new IOException("ARFFStream: @RELATION not found");
      }
    }
    return null;
  }
  
  private String readAttributes(BufferedReader reader) throws IOException {
    
    String line,upper;
    
    while ((line = reader.readLine()) != null) {
      ++currentLine;
      
      line = line.trim();
      if (line.length() == 0 || line.startsWith(COMMENT_SEQ)) {
        continue;
      }
      line = normalice(line);
      upper = line.toUpperCase();
      
      if (upper.startsWith(ATTRIBUTE_TAG)) {
        
        line = line.substring(ATTRIBUTE_TAG.length());
        line = line.trim();
        upper = line;
        
          // -----------------------
          // ATTRIBUTE, NOMINAL LIST
        if (upper.endsWith(NOMINAL_DTYPE)) {
          String nominalList = null;
          for (int i = line.length()-2; ; --i) {
            if (line.charAt(i) == '{') {
              nominalList = line.substring(i+1,line.length()-1);
              line = line.substring(0,i);
              break;
            }
          }
            // error
          if (nominalList == null) {
            throw new IOException("ARFFStream: Invalid nominal list. line "+currentLine);
          }
          attributeName.add(parse(line,1).get(0));
          attributeType.add(ARFFDataSet.NOMINAL);
          nominalValues.add(parse(nominalList,Integer.MAX_VALUE));
        }
        else if (upper.endsWith(" "+NUMERIC_DTYPE)
                  || upper.endsWith(" "+REAL_DTYPE)
                    || upper.endsWith(" "+INTEGER_DTYPE)
                      || upper.endsWith(" "+STRING_DTYPE)) {
          
          String type = "";
          
          for (int i = upper.length()-1; i >= 0; --i) {
            if (upper.charAt(i) == ' ') {
              type = upper.substring(i+1);
              line = line.substring(0,i);
              break;
            }
          }
          String name = parse(line,1).get(0);
          attributeName.add(name);
          nominalValues.add(null);
          
          switch (type) {
            case NUMERIC_DTYPE:
              attributeType.add(ARFFDataSet.NUMERIC);
              break;
            case REAL_DTYPE:
              attributeType.add(ARFFDataSet.REAL);
              break;
            case INTEGER_DTYPE:
              attributeType.add(ARFFDataSet.INTEGER);
              break;
            case STRING_DTYPE:
              attributeType.add(ARFFDataSet.STRING);
              break;
          }
        }
      }
        // -----------------------
        // ended list of attributes
      else break;
    }
    if (attributeName.isEmpty())
      throw new IOException("ARFFStream: @ATTRIBUTE not found. line "+currentLine);
    return line;
  }
  
  private void readData(BufferedReader reader,String header) throws IOException {
      // check header
    if (!header.toUpperCase().endsWith(ARFFStream.DATA_TAG)) {
      throw new IOException("ARFFStream: @DATA tag not found. line "+currentLine);
    }
    int n = dataSet.getSpace();
    String line;
    
    while ((line = reader.readLine()) != null) {
      ++currentLine;
      
      line = line.trim();
      if (line.length() == 0 || line.startsWith(COMMENT_SEQ)) {
        continue;
      }
      line = normalice(line);
      ArrayList<String> data = parse(line,n);
      if (data.size() < n) {
        throw new IOException("ARFFStream: Missing tokens. line "+currentLine);
      }
      dataSet.add(data.toArray());
    }
  }
  
  public ArrayList<String> parse(String src,int maxTokens) throws IOException {
    
    ArrayList<String> list = new ArrayList();
    src += ",";
    int len = src.length();
    String curr = "";
    
    for (int i = 0; i < len; ++i) {
      char c = src.charAt(i);
      
        // skip leading spaces
      if (c == ' ') continue;
      
      if (list.size() == maxTokens) {
        throw new IOException("ARFFStream: Unexpected token. line "+currentLine+" i: "+i);
      }
        // add current token
      if (c == ',') {
        list.add(curr);
        curr = "";
        continue;
      }
        // -------------
        // Quoted string
      else if (c == '\'' || c == '\"') {
        for (++i; i < len; ++i) {
          char v = src.charAt(i);
          if (v == c) {
            ++i;
            break;
          }
          if (v == '\\') ++i;
          if (i == len) {
            throw new IOException("ARFFStream: Invalid scape sequence. line "+currentLine);
          }
          curr += src.charAt(i);
        }
        if (i == len) {
          throw new IOException("ARFFStream: Missing "+c+ " character. line "+currentLine);
        }
      }
        // ----------------
        // No spaced string
      else if (c != ' ') {
        for (; i < len; ++i) {
          char v = src.charAt(i);
          if (v == ' ' || v == ',') break;
          if (c == '\\') ++i;
          if (i == len) {
            throw new IOException("ARFFStream: Invalid scape sequence. line "+currentLine);
          }
          curr += src.charAt(i);
        }
      }
        // skip trailing spaces
      while (i < len) {
        char v = src.charAt(i);
        if (v == ' ') ++i;
        else if (v == ',') break;
        else {
          throw new IOException("ARFFStream: Unexpected token. line "+currentLine+" i: "+i);
        }
      }
      --i;
    }
    return list;
  }
  
  private String normalice(String s) {
    return s.replace('\t',' ');
  }
  
  @Override
  public void write(OutputStream stream, DataSet ds) {
    // This implementation is further away...
    // not needed for moment
  }
}
